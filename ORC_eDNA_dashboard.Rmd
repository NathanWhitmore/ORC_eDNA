---
title: "ORC eDNA dashboard"
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "reproducible.co.nz", href: "https://reproducible.co.nz", align: right }
    orientation: rows
    vertical_layout: fill
    theme: spacelab
    source_code: embed 
---
<style>

body {
  padding-top: 70px;
}


.navbar-brand {
font-family: "Candara";
  font-weight: bold;
  font-size: 24px;
}


</style>


Sample locations
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Upload data from**

```{r}
radioButtons(
  "origin",
  label = "Either:",
  choices = list("Wilderlab API" = "wilderlab", 
                 "Local drive" = "local"),
  selected = "wilderlab"
)


```

**In this dashboard are 4 pages:**

1. **Sample locations**  - which shows all sampling locations
1. **By taxon** - which allows disaggregation by species/subspecies
1. **By spatial** - which allows disaggregation by species/subspecies or a specific taxon
1. **By cluster** - which allows investigation of species/subspecies clusters


**Your NZTCS data was last modified on: **


```{r}
library(wilderlab)
library(insect)
library(sf)
library(tidyverse)
library(lubridate)
library(leaflet)
library(shiny)
library(shinyWidgets)
library(flexdashboard)
library(plotly)
library(viridis)
library(DT)
library(readxl)
library(factoextra)
library(leaflet.extras)
library(geojsonsf)
library(jsonify)
library(stringr)


# read NZTCS data
nztcs <- read_excel("Data/NZTCS.xlsx")

renderUI({
  
  modification.time <- file.info("NZTCS.xlsx")$mtime
  print(modification.time)
  
  
})

  
 
```

**Please check that is the appropriate version for your analysis**


```{r}
radioButtons(
  "province",
  label = "Clip data by province?",
  choices = list(
    "No" = "No",
    "Yes" = "Yes"
  ),
  selected = "Yes"
  
)
```



```{r}
# maximum 50 MB
options(shiny.maxRequestSize=50*1024^2) 

# select provincial boundaries
boundaries <- st_read("Regional boundaries\\regional-council-2022-generalised.shp", quiet = TRUE)

province.choice <- sort(unique(boundaries$REGC2022_1))

```


```{r}
# only reveal if "yes" selected

conditionalPanel(
  condition = "input.province == 'Yes'",
  
  selectInput(
    "my.province",
    label = "Clip by province:",
    choices = province.choice,
    selected = "Otago Region"
  )
  
)

# crop to catchment (actually crop) to create usable subset
my.clip.province <- reactive({
  if (input$province == "Yes") {
    boundaries %>% filter(boundaries$REGC2022_1 == input$my.province)
    
  } else {
    boundaries
  }
})

```


Row {.tabset .tabset-fade}
-------------------------------------

```{r}
# APIs
APIs <- read_excel("Data/API keys.xlsx")


# get job info

jobs <- get_wilderdata("jobs", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
samples <- get_wilderdata("samples", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
taxa <- get_wilderdata("taxa", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)

# get full record
records <- vector(mode = "list", length = nrow(jobs))
for(i in seq_along(records)){
  records[[i]] <- get_wilderdata("records", JobID = jobs$JobID[i],
                                 key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
}
records <- do.call("rbind", records)


# add taxa info
tdb <- taxa[, 1:4]
colnames(tdb) <- c("taxID", "parent_taxID", "rank", "name")
lineages <- insect::get_lineage(records$TaxID, tdb)

# add classification
records$phylum <- sapply(lineages, "[", "phylum")
records$class <- sapply(lineages, "[", "class")
records$order <- sapply(lineages, "[", "order")
records$family <- sapply(lineages, "[", "family")
records$genus <- sapply(lineages, "[", "genus")
records$species <- sapply(lineages, "[", "species")
records$Latitude <- samples$Latitude[match(records$UID,samples$UID)]
records$Longitude <- samples$Longitude[match(records$UID,samples$UID)]
records$ClientSampleID <- samples$ClientSampleID[match(records$UID,samples$UID)]

# date join
date.id <- samples[, c("UID", "CollectionDate")]

# add dates to record
eDNA <- left_join(records, date.id, by = "UID")

```





```{r, message = FALSE}
# read in eDNA data (fast)
eDNA <- eDNA %>% # data provided by Wilderlab
  janitor::clean_names()


# clip by province
eDNA_my_prov_sf <- reactive ({
  eDNA_my_prov_sf  <- eDNA %>%
    st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
    st_intersection(my.clip.province())
  
  # fix dates
  eDNA_my_prov_sf$collection_date <-
    ymd(eDNA_my_prov_sf$collection_date)
  
  # unique coord
  eDNA_coord <- st_coordinates(eDNA_my_prov_sf) %>% as.data.frame()
  eDNA_coord$xy <- paste(eDNA_coord$X, eDNA_coord$Y)
  eDNA_my_prov_sf <- cbind(eDNA_my_prov_sf, eDNA_coord$xy)
  eDNA_my_prov_sf
  
})


# sample locations (fast) by first date
site.locations <- reactive({
  
  eDNA_my_prov_sf() %>%
    group_by(eDNA_coord.xy) %>%
    filter(collection_date == min(collection_date)) %>%
    slice(1)

})


# make base map
basemap <- reactive({
  leaflet() %>%
    # add different provider tiles
    addProviderTiles("OpenStreetMap",
                     group = "Open Street Map") %>%
    addProviderTiles("Esri.WorldImagery",
                     group = "World") %>%
    addPolygons(
      data = my.clip.province(),
      weight = 1,
      fillOpacity = 0.05,
      color = "white"
    ) %>%
    addLayersControl(baseGroups = c("World", "Open Street Map"),
                     position = "topleft") 
  
})


# visualise site locations
# renderLeaflet({

#  basemap() %>%
#  addCircleMarkers(data = site.locations() ,
#                   clusterOptions = markerClusterOptions(),
#                   popup = ~client_sample_id) %>%
#  addMiniMap()

#})

```

### Gridded map (10 sq km)

```{r}


renderLeaflet ({
  # override any random origin of grid if it exists
  set.seed(500)
  
  catch.2193 <- my.clip.province() %>%
    st_transform(crs = 2193)
  
  
  grid <- st_make_grid(
    catch.2193,
    cellsize = c(10000, 10000),
    crs = 2193,
    square = TRUE
  ) %>%
    st_as_sf()
  
  inter <- st_intersection(catch.2193, grid) %>%
    st_transform(crs = 4326)
  
  
  # group by coord$xy and date
  eDNA.counts <- eDNA_my_prov_sf() %>%
    group_by(eDNA_coord.xy,  uid) %>%
    tally()
  
  # count intersections with grid and line
  my.intersects <- st_intersects(inter, eDNA.counts)
  
  # make raster
  inter$counted <- lengths(my.intersects)
  inter$counted <- ifelse(inter$counted == 0, NA, inter$counted)
  
  # Create a continuous palette function
  
  if (sum(inter$counted, na.rm = TRUE) > 0) {
    my.pal <-
      colorNumeric(palette = "Reds",
                   domain = inter$counted,
                   na.color = NA)
    
    # return NA for 0 but otherwise 1 for transparency
    factop <- function(x) {
      ifelse(is.na(x), 0, 0.7)
    }
    
    leaflet() %>%
      # add different provider tiles
      addProviderTiles("OpenStreetMap",
                       group = "Open Street Map") %>%
      addProviderTiles("Esri.WorldImagery",
                       group = "World") %>%
      addPolygons(
        data = inter,
        weight = 1,
        fillOpacity = ~ factop(counted),
        fillColor = ~ my.pal(counted),
        color = "white"
      ) %>%
      addLegend(
        data = inter ,
        position = "topright",
        pal = my.pal,
        values = inter$counted,
        title = "Samples per 10 sq km",
        na.label = ""
      ) %>%
      addMiniMap() %>%
      addScaleBar(position = "topright",
                  options = scaleBarOptions(imperial = FALSE))  %>%
      addLayersControl(baseGroups = c("World", "Open Street Map"),
                       position = "topleft")
    
  } else {
    leaflet() %>%
      # add different provider tiles
      addProviderTiles("OpenStreetMap",
                       group = "Open Street Map") %>%
      addProviderTiles("Esri.WorldImagery",
                       group = "World") %>%
      addPolygons(data = inter,
                  weight = 1,
                  color = "white") %>%
      addScaleBar(position = "topright",
                  options = scaleBarOptions(imperial = FALSE)) %>%
      addLayersControl(baseGroups = c("World", "Open Street Map"),
                       position = "topleft")
    
  }
  
})
```




By taxonomy
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Filter by taxonomy**



```{r}
selectInput(
  "Classification",
  label = "Taxonomic group",
  choices = list(
    "Phylum" = "phylum",
    "Class" = "class",
    "Order" = "order",
    "Family" = "family",
    "Genus" = "genus",
    "Species" = "species"
  ),
      selected = "species"
)


# reactive taxonomic choices

renderUI({
  
  my.selection <- eDNA_my_prov_sf() %>% select(input$Classification)
  st_geometry(my.selection) <- NULL
  
  choices <- sort(unique(my.selection[, 1]))
  
  selectInput("Taxon",
              label = str_to_title(input$Classification),
              choices = sort(unique(choices)),
              selected = "Galaxias gollumoides")
  
})


# reactive species/subspecies choices

my.spp <- reactive({
  x <- as.character(input$Classification)
  
  eDNA_my_prov_sf() %>% 
    filter(eval(str2expression(x)) == input$Taxon)
  
})


```

<br/>

**Legend**

Blue pins = presence recorded
White circles = absence recorded 

*Note: circles transparency relates to number of records.*


```{r}
my.taxon <- reactive({
  
  # start reactive
  
  x <- as.character(input$Classification)
  eDNA_my_prov_sf() %>% 
    filter(eval(str2expression(x)) == input$Taxon)
  
})

my.coord <- reactive ({
  
  my.coord <- st_coordinates(site.locations()) %>%
     as.data.frame()
  
  my.coord$xy <- paste(my.coord$X, my.coord$Y)
  my.coord
  
})

```

<br/>

**Download data**

```{r}
# Create placeholder for the download button
uiOutput("downloadtaxUI")
```

```{r, echo = FALSE}
output$downloadtaxUI <- renderUI( {
  downloadButton("downtaxBtn", "Sample data", style = "width:100%;")
})

output$downtaxBtn <- downloadHandler(
  filename = function() {'Name your by taxonomy file.csv'},
  content = function(file) {
    write.csv(my.species.coord.tax(), file, row.names = FALSE)
  }
)
```


Row {data-height=75}
-------------------------------------

### Percentage of locations
```{r}

percentage_of_locations <- reactive({

   round(length(unique(my.sf.coord()$xy))/
    length(unique(my.coord()$xy)),4)  * 100
})


renderGauge({
  
  req(my.sf.coord(), my.coord(), percentage_of_locations())
  
gauge(percentage_of_locations(), min = 0, max = 100,  symbol = '%',
    gaugeSectors(colors = "#f93b25"))
})
```


### No. of unique sites
```{r}

no_of_actual_sites <- reactive({
  
  length(unique(my.sf.coord()$xy))
  
})

renderValueBox({
  
  req(input$Taxon)

  valueBox(no_of_actual_sites(), color = " #7dcea0")
  
})
```



### No. of unique dates
```{r}

no_dates <- reactive({
  
  length(unique(my.taxon()$collection_date))
  
})

renderValueBox({
  
  req(input$Taxon)
  
  valueBox(no_dates(),  color = "#7fb3d5")
  
})
```


Row {.tabset .tabset-fade}
-------------------------------------

### Presence / absence


```{r}


loc.map <- reactive({
  
  req(input$Taxon)
  
  # visualise site locations
  basemap() %>%
   addMiniMap()
  
})
  

```



```{r}
renderLeaflet({
  
  req(input$Taxon)
  
  loc.map() %>%   
    addCircleMarkers(
      data = site.locations(),
      color = "white",
      fillOpacity = 0.01,
      radius = 10
    ) %>%
   addMarkers(
      data = my.taxon() ,
      #color = "red",
      #fillOpacity = 0.01,
      popup = paste(
        "Date:",
        my.taxon()$collection_date,
        "<br>",
        "Job id:",
        my.taxon()$job_id,
        "<br>",
        "Client:",
        my.taxon()$client_sample_id,
        "<br>",
        "Count:",
        my.taxon()$count,
        "<br>",
        "RID:",
        my.taxon()$rid,
        "<br>"
      )) %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
  
})
```


### NZTCS data

```{r}

sp.info <- reactive({
  
  req(input$Taxon)
  
  
  if(input$Classification != "species"){
    
    data.frame(Information = paste("Only available for species, not ", 
                                   input$Classification))
    
  } else {
  
  
  
  if (any(nztcs$`Current Species Name` == input$Taxon)){
  
  sp.info <- nztcs %>% filter(`Current Species Name` ==
                                input$Taxon)
  sp.info <- sp.info[, 1:41]
  sp.info <- t(sp.info) %>% as.data.frame()
  
  sp.info <- sp.info %>% rownames_to_column()
  colnames(sp.info) <- c("Attribute", "Status")
  
  sp.info} else {
    
    empty <- data.frame(Species = input$Taxon, Status = "Is either not present in the NZTCS or appears under a different name")
    empty
  }
    
  }
  
})



renderDataTable({
  
  req(input$Taxon)
  
  
  datatable(
    sp.info(),
    rownames = FALSE,
    options = list(
      filter = "none",
      scrollY = "500px",
      "pageLength" = 42,
      searching = FALSE,
      dom = "t",
      info = FALSE
    )
  )
  
  
}, fillContainer = TRUE) 
  



```

### Sample data


```{r}
# make by taxonomy table


my.species.coord.tax <- reactive({
  temp <- my.taxon()
  my.coord <- st_coordinates(temp)
  st_geometry(temp) <- NULL
  my.species.coord.tax <- cbind(temp, my.coord) %>%
    rename(lat = Y, long = X)
  
  my.species.coord.tax <- my.species.coord.tax %>%
    select(
      phylum,
      class,
      order,
      genus,
      species,
      common_name,
      group,
      client_sample_id,
      collection_date,
      lat,
      long,
      count,
      hid,
      uid
    )
  
  my.species.coord.tax
})

renderDataTable({
  req(input$Taxon)
  
  
  
  datatable(my.species.coord.tax(),
            options = list(
              filter = "none",
              scrollX = TRUE,
              "pageLength" = 8
            ))
  
  
  
})

```

### Meta data


```{r}



# reactive elements
my.sf.coord <- reactive({
  
  req(input$Taxon)
  
  my.sf.coord <- st_coordinates(my.taxon()) %>%
     as.data.frame()
  my.sf.coord$xy <- paste(my.sf.coord$X, my.sf.coord$Y)
  my.sf.coord
  
})
   
   

renderPrint({
  

  
list(
    species = input$Taxon,
    `no of dates` = no_dates(),
    dates = unique(my.taxon()$collection_date),
    `no. of site sample names (note: not standardised, synonyms possible)`= length(unique(my.taxon()$client_sample_id)),
    `site / client id names` = unique(my.taxon()$client_sample_id),
    `no. of actual sites with species detected` = no_of_actual_sites(),
    `total sampling locations` = length(unique(my.coord()$xy)),
    `percentage of sampling locations` = percentage_of_locations() 
    
  )
  
})

    



```


```{r}
my.group <- reactive({
  
  # input$layname
  
  eDNA.layname <- eDNA_my_prov_sf() %>% filter(group == input$layname)
  eDNA.layname
  
})
```

```{r}
# join by NZTCS

my.nztcs <- reactive({
  
  my.group <- my.group()
  my.group <- my.group %>% drop_na(species)
  
  nztcs$species <- nztcs$`Current Species Name`
  my.nztcs <- left_join(my.group, nztcs, by = "species")
 
  my.nztcs 
  
})

```

By threat status
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

Choose group to filter:

```{r}
# choose 
renderUI({

  selectInput("layname",
              label = "Select group",
              choices = sort(unique(eDNA$group)),
              selected = "Fish")
})
```

*Note: if no species are found in the NZTCS excel file provided the drop-down menu below will be blank and no map will be rendered*

```{r}
# category drop down
renderUI({
  
  req(input$layname)
  
  my.selection <- my.nztcs()
  st_geometry(my.selection) <- NULL
  
  choices <- sort(unique(my.selection$Category))
  
  selectInput("category",
              label = "Threat category",
              choices = choices,
              selected = "Not Threatened")
  
})

```

```{r}
# category and status
my.category <- reactive({
  
   req(input$layname)
  
  
  my.nztcs() %>% filter(Category == input$category)
  
})

```


```{r}
# status drop down

renderUI({
  
  req(input$category)
  
  conditionalPanel(
    condition = "input.category == 'Threatened'",
    
    selectInput(
      "status",
      label = "Threat status",
      choices = sort(unique(my.category()$Status)),
      selected = "Not Threatened"
    )
    
  )
  
})
```

```{r}
# category and status
my.status <- reactive({
  
  my.nztcs()  %>% filter(Status == input$status)
  
})

```


<br/>

**Download**

```{r}
# Create placeholder for the download button
uiOutput("download_filter_UI")

output$download_filter_UI <- renderUI( {
  downloadButton("down_filter_Btn", "Filtered species", style = "width:100%;")
})

output$down_filter_Btn <- downloadHandler(
  filename = function() {'Name your by threat listing species file.csv'},
  content = function(file) {
    write.csv(species.in.your.filter(), file, row.names = FALSE)
  }
)
```

```{r}
# Create placeholder for the download button
uiOutput("download_unmatched_UI")

output$download_unmatched_UI <- renderUI( {
  downloadButton("down_unmatched_Btn", "Unmatched species", style = "width:100%;")
})

output$down_unmatched_Btn <- downloadHandler(
  filename = function() {'Name your by threat listing unmatched species file.csv'},
  content = function(file) {
    write.csv(my.incompletes(), file, row.names = FALSE)
  }
)
```

```{r}
# Create placeholder for the download button
uiOutput("download_summary_UI")

output$download_summary_UI <- renderUI( {
  downloadButton("down_summary_Btn", "Summary", style = "width:100%;")
})

output$down_summary_Btn <- downloadHandler(
  filename = function() {'Name your by threat listing summary file.csv'},
  content = function(file) {
    write.csv(nztcs_summary(), file, row.names = FALSE)
  }
)
```

Row {.tabset .tabset-fade}
-------------------------------------

### Zoomable map


```{r}
renderLeaflet({
  
  req(input$category)
  
  if(input$category == "Threatened"){
  
  loc.map() %>%   
    addCircleMarkers(
      data = my.status(),
      color = "red",
      fillOpacity = 0.01,
      radius = 10
    ) %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
    
  } else {
    
  loc.map() %>%   
    addCircleMarkers(
      data = my.category(),
      color = "red",
      fillOpacity = 0.01,
      radius = 10
    ) %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE))     
    
  }
  
})
```


### Species in your filter


```{r}
# summary


species.in.your.filter <- reactive({
  
  if (input$category == "Threatened") {
    temp_status <- my.status() %>%
      group_by(species, Category, Status) %>%
      summarise(instances = n())
    st_geometry(temp_status) <- NULL
    temp_status
    
  } else {
    temp_category <- my.category() %>%
      group_by(species, Category, Status) %>%
      summarise(instances = n())
    st_geometry(temp_category) <- NULL
    temp_category
  }
  
  
})

renderDataTable({
  req(input$category)
  
  species.in.your.filter()
  
})
```

### Unmatched eDNA samples

These samples do not have a NZTCS listing:

```{r}
my.incompletes <- reactive({
  
  my.incompletes <-
    my.nztcs()[!complete.cases(my.nztcs()$Category),] %>%
    as.data.frame()
  
  my.incompletes <- my.incompletes %>%
    select(c("phylum", "class" , "order", "family" , "genus", "species")) %>%
    distinct()
  my.incompletes
})


renderDataTable({
  req(input$category)
  
  datatable(my.incompletes(),
            options = list(
              filter = "none",
              scrollX = TRUE,
              "pageLength" = 15
            ))
  
})
```

### Summary (all categories & statuses)

```{r}

nztcs_summary <- reactive({
  
  req(input$category)
  
  interim <-
    my.nztcs() %>% group_by(species, Category, Status)  %>%
    summarise(species = n())
  interim <- interim %>% group_by(Category, Status) %>% 
    summarise(species = n())
  
  st_geometry(interim) <- NULL
  
  # replace NAs with "unmatched"
  interim$Category <-
    ifelse(is.na(interim$Category), "No match in NZTCS", interim$Category)
  interim$Status <-
    ifelse(is.na(interim$Status), "No match in NZTCS", interim$Status)
  interim
  
})


renderDataTable({
  
  req(input$category)
  
  datatable(nztcs_summary(),
            options = list(
              filter = "none",
              scrollX = TRUE,
              "pageLength" = 15
            ))
  
})
```


By spatial
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Options**

You can either:

1. Upload a predefined ESRI shapefile (from the **Spatial Selection** folder) or 
2. Select an area either square, circular, or a polygon on the fly

The eDNA data will extracted for your selected area.

**Please select**

```{r}
radioButtons(
  "choice",
  label = "One of:",
  choices = list("upload spatial selection" = "upload", "draw now" = "draw"),
  selected = "draw"
)

```

```{r}
# reactive data from maps


dataset <- reactive({
  
  if (input$choice == "upload") {
    filenames <- list.files(paste0(getwd(), "/Spatial Selection"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    
    st_read(paste0("Spatial Selection/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
  } else {
    
    my.spatial.selection  <- NULL
    my.spatial.selection  
  }
  
})


# selection from drawing
sp.file <- eventReactive(input$mymap_draw_new_feature,{
  
    feature <- input$mymap_draw_new_feature
    
    sp.file <-  geojson_sf(to_json(feature, unbox = TRUE)) %>%
      st_as_sf()
    
    sp.file
     
  })

```


```{r}
renderUI({
  
  # round to nearest 10
  nearest <- 10
  my.max <- ceiling(nrow(all.selection())/nearest)*nearest
  
  sliderInput("entries", "Number of entries to graph:",
            min = 10, max = my.max, value = 50, step = 10, ticks = FALSE)
  
})

renderUI({
  
  spp <- nrow(all.selection())
  paste("Total taxa present: ", spp)


})

```

*Note: When drawing a new polygon please allow a short period of time for the plot to render using the new data.*


Row {.tabset .tabset-fade}
-------------------------------------

### Zoomable map


```{r}
my.selection <- reactive({
  
  if (input$choice == "upload") {
    
    eDNA_my_prov_sf() %>%
      st_as_sf(coords = c("longitude", "latitude"),
               crs = 4326) %>%
      st_intersection(dataset())
    
  } else {
    
    if (sp.file()$feature_type == "circle") {
      
      my.circle <- st_buffer(sp.file(), sp.file()$radius) 
      
      eDNA_my_prov_sf() %>%
        st_as_sf(coords = c("longitude", "latitude"),
                 crs = 4326) %>%
        st_intersection(my.circle)
      
    } else {
      
      eDNA_my_prov_sf() %>%
        st_as_sf(coords = c("longitude", "latitude"),
                 crs = 4326) %>%
        st_intersection(sp.file())
      
    }
  }

})

```

```{r}

leafletOutput("mymap", height = 800)

output$mymap <- renderLeaflet({
  if (input$choice == "upload") {
    
    site.polygon <- dataset() %>% st_zm()
    
    new.map <- leaflet() %>%
      # add base maps
      addProviderTiles("OpenStreetMap",
                       # give the layer a name
                       group = "Open Street Map") %>%
      addProviderTiles("Esri.WorldImagery",
                       # give the layer a name
                       group = "World") %>%
      addProviderTiles("Stamen.Terrain",
                       # give the layer a name
                       group = "Terrain") %>%
      addLayersControl(
        baseGroups = c("World", "Terrain", "Open Street Map"),
        position = "topleft"
      ) %>%
      addMarkers(data = site.locations()) %>%
      addPolygons(
        data = my.clip.province(),
        weight = 1,
        fillOpacity = 0.05,
        color = "white"
      ) %>%
      addPolygons(data = site.polygon, color = "white") %>%
      addMiniMap() %>%
      addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
    
    
    
  } else {
    leaflet() %>%
      
      # add base maps
      addProviderTiles("OpenStreetMap",
                       # give the layer a name
                       group = "Open Street Map") %>%
      addProviderTiles("Esri.WorldImagery",
                       # give the layer a name
                       group = "World") %>%
      addProviderTiles("Stamen.Terrain",
                       # give the layer a name
                       group = "Terrain") %>%
      
      addPolygons(
        data = my.clip.province(),
        weight = 1,
        fillOpacity = 0.05,
        color = "white"
      ) %>%
      
      # add drawing tools
      addDrawToolbar(
        polylineOptions = FALSE,
        markerOptions = FALSE,
        circleMarkerOptions = FALSE,
        singleFeature = TRUE,
        
        
        targetGroup = 'draw',
        editOptions = editToolbarOptions(edit = FALSE, remove = TRUE)
      )  %>%
      
      # add layers
      addLayersControl(overlayGroups = c('draw'),
                       options =
                         layersControlOptions(collapsed = FALSE)) %>%
      
      addLayersControl(
        baseGroups = c("World", "Terrain", "Open Street Map"),
        # position it on the topleft
        position = "topleft"
      ) %>%
      
      addMarkers(data = site.locations()) %>%
      addMiniMap() %>%
      addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
    
  }
  
})

```

### Taxa present
```{r}
all.selection <- reactive({
  
  my.table <- my.selection() %>% 
    filter(rank == "species" |rank == "subspecies") %>% 
    group_by(name)  %>%
    summarise(instances = n(),
              `average sequence count` = round(mean(count),1),
              `range` = paste(min(count),"â€“", max(count) )
              ) 
  
  st_geometry(my.table) <- NULL
  my.table
  
})
```


```{r}
selection <- reactive({
  
    req(input$entries)
  
    selection <- all.selection() %>% 
      slice_max(instances, n = input$entries) 
  
    selection$name <- as.factor(selection$name)
    selection <- selection %>% mutate(name, name = fct_reorder(name, -instances))
    selection
  
})


renderPlotly({

  ggplot(selection(), aes(x = name ,
      y = instances,
      fill = `average sequence count`,
      text = paste("range:", range))) +
    theme_minimal() +
    geom_col() +
    scale_fill_viridis(option = "plasma") +
    xlab("") +
    ylab("Instances\n") +
    ggtitle("Taxon present in spatial selection") +
    theme(axis.title = element_text(size = 16, colour = "grey20")) +
    theme(axis.text.x = element_text(
      size = 12,
      colour = "grey20",
      angle = 90,
      hjust = 1,
      vjust = 0.5
    ))
  
})
```

### Data

```{r}
renderDataTable({
  
    datatable(all.selection(), 
                  options = list(filter = "none",
                  scrollX = TRUE, "pageLength" = 15))
    
})

```


### Area

```{r}


area <- reactive ({
  
  if (input$choice == "upload") {
    
    dataset() %>% st_area()
    
  } else {
    
    if (sp.file()$feature_type == "circle") {
      
      st_buffer(sp.file(), sp.file()$radius) %>% st_area()
      
    } else {
      sp.file() %>% st_area()
      
    }
    
  }
  
})
  
renderUI({  
  
  line1 <- paste("area (sq m) =",  round(area(),2))
  line2 <-paste("area (ha) =",  round(area()/10000,2))
  line3 <-paste("area (km) =",  round(area()/1000000,2))
  
  HTML(paste(line1, line2, line3, sep = '<br/>'))

  
})
    
```




By cluster
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Explore patterns in biodiversity via clustering**

Clusters are solely constructed around dissimilarities in biodiversity (i.e. spatial elements are ignored).

<br/>


**Number of clusters**


```{r}
sliderInput("cluster", label = "Move slider:", min = 2, 
        max = 10, value = 5, step = 1)
```

<br/>

**Hierarchial clustering (via dissimilarities)**

```{r}
selectInput("hier",
            label = "Method:",
            choices = c( "complete", "ward.D", "ward.D2"),
            selected = "ward.D")
```

Row {.tabset .tabset-fade}
-------------------------------------

### Map

```{r}

renderLeaflet({
  my.dna <- eDNA[, c("name", "latitude", "longitude", "uid")]
  
  # make future rowname
  my.dna$longlat <- paste(my.dna$longitude, my.dna$latitude)
  
  # add count
  my.dna$count <- 1
  
  # group and summarise
  my.dnax <- my.dna  %>% group_by(longlat,  name) %>%
    summarise(presence = sum(count))
  
  # reduce so row number is correct
  my.dnax$presence <- ifelse(my.dnax$presence > 1, 1, 1)
  
  # pivot wider
  my.dnax <- my.dnax %>% pivot_wider(names_from = name,
                                     values_from = presence) %>% as.data.frame()
  
  # make row names
  rownames(my.dnax) <- paste0(my.dnax$longlat)
  
  # remove unnecessary columns
  my.dnax$longlat <- NULL
  my.dnax$uid <- NULL
  
  # change NAs to 0
  my.dnax[is.na(my.dnax)] <- 0
  
  
  clust.map <- my.dnax
  
  # assign cluster
  my.clust <-  my.dnax %>%
    dist(method = "euclidean") %>%
    hclust(method = input$hier)
  
  clust.map$groups <- as.factor(cutree(my.clust, k = input$cluster))
  
  # simplify and back calculate row names
  clust.map$longlat <- rownames(clust.map)
  clust.map <- clust.map[, c("groups", "longlat")]
  
  clust.map <-
    clust.map %>% separate(longlat, c("longitude", "latitude"),  sep = " ")
  
  clust.map <- st_as_sf(clust.map,
                        coords = c("longitude", "latitude"),
                        crs = 4326)
  
  clust.map <- as_Spatial(clust.map)
  
  # make base map
  # map.clust <- leaflet() %>%
  
  
  beatCol <- colorFactor(palette = 'RdYlGn', clust.map$groups)
  
  
  # visualise site locations
  basemap() %>%
    addCircleMarkers(data = clust.map, color = ~ beatCol(groups)) %>%
    addMiniMap() %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
    

})
```

### Dendrogram

```{r}
my.clust <- reactive ({
  # simplifed data
  my.dna <- eDNA %>% filter(rank == "species" |
                                rank == "subspecies" )
  
  my.dna <- my.dna[, c("name", "latitude", "longitude", "uid")]
  
  # make future rowname
  my.dna$longlat <- paste(my.dna$longitude, my.dna$latitude)
  
  # add count
  my.dna$count <- 1
  
  # group and summarise
  my.dnax <- my.dna  %>% group_by(longlat,  name) %>%
    summarise(presence = sum(count))
  
  # reduce so row number is correct
  my.dnax$presence <- ifelse(my.dnax$presence > 1, 1, 1)
  
  # pivot wider
  my.dnax <- my.dnax %>% pivot_wider(names_from = name,
                                     values_from = presence) %>% as.data.frame()
  
  # make row names
  rownames(my.dnax) <- paste0(my.dnax$longlat)
  
  # remove unnecessary columns
  my.dnax$longlat <- NULL
  my.dnax$uid <- NULL
  
  # change NAs to 0
  my.dnax[is.na(my.dnax)] <- 0
  

  # hierarchical clustering
  my.clust <-  my.dnax %>%
    dist(method = "euclidean") %>%
    hclust(method = input$hier)
  
  my.clust
  
})
  
  
# graph

renderPlot({
  
  fviz_dend(my.clust(), k=input$cluster, size = 3)
  
})


```




Test existing knowledge
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Provide files**

Please ensure a *maximum* of 1 spatial file / spatial file set is placed into the correct folder. Use the **File check** tab to check.

If you alter the inputs you will need to push "activate" to update the results.



```{r}

# spatial radio button

radioButtons(
  "spatialfile",
  label = "Type",
  choices = list(
    "Single species point" = "point",
    "Single species polyline" = "polyline",
    "Single species polygon" = "polygon",
    "Catchment polygon" = "catchment",
    "Non migratory freshwater fish distribution" = "nmfish"
  ),
  selected = "nmfish"
  
)
```


**Your current eDNA record is of:**

```{r}
# base species is reactive to ensure it corresponds with data

renderUI({
  
  input$Taxon
  
})
```

```{r}
# species choices for catchment

renderUI({
  conditionalPanel(
    condition = "input.spatialfile != 'nmfish'",
    
    textInput("sp.name",
              label = HTML("<b>Name comparison species</b>"),
              value = "Write here")
  )
})

```

```{r}
# my.shape determined by user selection

my.shape <- reactive({
  
  if (input$spatialfile == "nmfish") {
    my.shape <-
      st_read(
        "Your Non-Migratory Freshwater Fish Distribution/Non_migratory_Freshwater_Fish_Distribution.shp",
        quiet = TRUE
      ) %>%
      st_transform(crs = 4326)
    my.shape
    
    
  } else if (input$spatialfile == "catchment") {
    filenames <- list.files(paste0(getwd(), "/Your Catchment Polygons"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape2  <-
      st_read(paste0("Your Catchment Polygons/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape2
    
  } else if (input$spatialfile == "polyline") {
    
    filenames <- list.files(paste0(getwd(), "/Your Species Polylines"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape3  <-
      st_read(paste0("Your Species Polylines/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape3
    
  } else if  (input$spatialfile == "polygon"){
  
  filenames <- list.files(paste0(getwd(), "/Your Species Polygons"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape4  <-
      st_read(paste0("Your Species Polygons/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape4
    
  } else {
  
  filenames <- list.files(paste0(getwd(), "/Your Species Points"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape5  <-
      st_read(paste0("Your Species Points/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape5
    
  }
    
})
```


```{r}
# my.catchment conditional selections
# conditional on submit

catchment.choices <- reactive({
                         
  if (input$spatialfile == "catchment") {
    poly.catchment <- my.shape()
    st_geometry(poly.catchment) <- NULL
    catchment.names <- select_if(poly.catchment, is.character) %>% names()
    catchment.choices <- sort(catchment.names)
    catchment.choices
    
  } else {
    catchment.choices <- NULL
    catchment.choices
  }
})

# species choices for catchment
renderUI({
  conditionalPanel(condition = "input.spatialfile == 'catchment'",
                   
                   selectInput("catchment.var",
                               label = "Pop up information from:",
                               choices = catchment.choices()))
  
})
```


```{r}


# nmfish conditional selections
non.mig.choices <- reactive({
                         
  if (input$spatialfile == "nmfish") {
    nmfish <- my.shape()
    st_geometry(nmfish) <- NULL
    non.mig.choices <- sort(unique(nmfish[, 3]))
    non.mig.choices
  }
})

# species choices from nmfish
renderUI({
  conditionalPanel(condition = "input.spatialfile == 'nmfish'",
                   
                   selectInput("non.mig.sp",
                               label = HTML("<b>Comparison species</b>"),
                               choices = non.mig.choices()))
  
})


# distance threshold for nmfish
renderUI({
  conditionalPanel(
    condition = "input.spatialfile != 'catchment'",
    
    numericInput("aberrant", 
                 label = HTML("<b>Distance threshold for aberrant result, (km) </b>")
                 , value = 0.250)
  )
  
})
```
  


```{r}
# Write note for csv file

renderUI({
  conditionalPanel(
    condition = "input.spatialfile != 'catchment'",
    
    numericInput("notes", 
                 label = HTML("Write note for csv file"),
                                       value = "Enter text...")
    )
  
})  
  
```

<br/>

```{r}
# add submit button
actionButton("submit", label = "Activate")
```

<br/>

**Download**

```{r}
# Create placeholder for the download button
uiOutput("downloadfish")
```

```{r, echo = FALSE}
output$downloadfish <- renderUI( {
  downloadButton("downBtnfish", "Aberrant entries", style = "width:100%;")
})

output$downBtnfish <- downloadHandler(
  filename = function() { paste0("edna-", input$Taxon, " vs ", 
                                 "target-", input$non.mig.sp, " ",
                                 "threshold-", input$aberrant,"m",".csv")},
  content = function(file) {
    write.csv(aberrant(), file, row.names = FALSE)
  }
)
```




Row {.tabset .tabset-fade}
-------------------------------------



### Zoomable map

```{r}
my.map <- eventReactive(input$submit,
                        {
                           nearest <- NULL
                          
                          if (input$spatialfile == "nmfish") {
                            non.mig.sp <-
                              my.shape() %>%
                              filter(Species == input$non.mig.sp) %>%
                              st_make_valid()
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), non.mig.sp)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), non.mig.sp[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and nearest known 
                            # location via loop
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  non.mig.sp[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            
                            loc.map() %>%
                              addCircleMarkers(data = my.taxon(),
                                               color = "red",
                                               fillOpacity = 0.01,
                                               radius = 10) %>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) %>%
                              addPolylines(data = non.mig.sp ,
                                           color = "yellow",
                                           weight = 3)
                            
                            
                          } else if (input$spatialfile == "polyline") {
                            
                            my.species <-
                              my.shape() %>%
                              st_make_valid()
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), my.species)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), my.species[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and 
                            # nearest known location via loop
                            
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  my.species[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            
                            loc.map() %>%
                              addCircleMarkers(data = my.taxon(),
                                               color = "red",
                                               fillOpacity = 0.01,
                                               radius = 10) %>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) %>%
                              addPolylines(data = my.species ,
                                           color = "yellow",
                                           weight = 3)
                            
                            
                          } else if (input$spatialfile == "catchment") {
                            # work out if in or out
                            my.catchment <- my.shape()
                            my.catchment$present <-
                              lengths(st_intersects(my.catchment, my.taxon())) > 0
                            my.catchment$present <-
                              ifelse(my.catchment$present == TRUE, "red", "black")
                            
                            loc.map() %>%
                              addCircleMarkers(data = my.taxon(),
                                               color = "red",
                                               fillOpacity = 0.01,
                                               radius = 10) %>%
                              addPolygons(
                                data = my.catchment,
                                fillColor = ~ present,
                                color = "white",
                                weight = 1,
                                fillOpacity = 0.3,
                                highlightOptions = highlightOptions(
                                  color = 'white',
                                  weight = 1,
                                  bringToFront = TRUE
                                ),
                                popup = my.catchment[[input$catchment.var]]
                              )
                            
                            
                          } else if (input$spatialfile == "polygon") {
                            
                            # work out if in or out
                            my.polygon <- my.shape()
                            my.polygon$present <-
                              lengths(st_intersects(my.polygon, my.taxon())) > 0
                            my.polygon$present <-
                              ifelse(my.polygon$present == TRUE, "red", "black")
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), my.polygon)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), my.polygon[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and 
                            # nearest known location via loop
                            
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  my.polygon[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            loc.map() %>%
                              addCircleMarkers(data = my.taxon(),
                                               color = "red",
                                               fillOpacity = 0.01,
                                               radius = 10) %>%
                              addPolygons(
                                data = my.polygon,
                                fillColor = "white",
                                color = "white",
                                weight = 1,
                                fillOpacity = 0.3,
                                highlightOptions = highlightOptions(
                                  color = 'white',
                                  weight = 1,
                                  bringToFront = TRUE
                                )
                              )%>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) 
                            
                          } else {
                            
                             my.points <- my.shape() 
                             
                             # get nearest
                            nearest <- st_nearest_feature(my.taxon(), my.points )
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), my.points[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and 
                            # nearest known location via loop
                            
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  my.points[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            
                            loc.map() %>%
                               addCircleMarkers(data = my.taxon(),
                                               color = "red",
                                               fillOpacity = 0.01,
                                               radius = 10) %>%
                              addCircleMarkers(data = my.points, 
                                               color = "yellow") %>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) 
                            
                            
                          }
                          
                        })


renderLeaflet ({
  
  my.map() %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
  
  
})
```




### Sample data

```{r}

aberrant <- eventReactive(input$submit,
                       {
  
 if (input$spatialfile != "catchment") {
   
   if (input$spatialfile == "nmfish") {
     
   my.selected.species <- my.shape() %>% 
     filter(Species == input$non.mig.sp) %>% 
     st_make_valid()
   
   } else if (input$spatialfile != "nmfish"){
     
    my.selected.species <- my.shape() %>% 
     st_make_valid()
     
   }
  
    # get nearest
    nearest <- st_nearest_feature(my.taxon(), my.selected.species)
    
    # flatten (change crs to NZTM for distance calculation)
    my.taxon.flat <- my.taxon() %>% st_transform(crs = 2193)
    my.selected.species.flat <- my.selected.species  %>% 
      st_transform(crs = 2193)
    
    # get distance
    dist.m <-
      st_distance(my.taxon.flat , my.selected.species.flat[nearest,], 
                  by_element = TRUE)
    dist.m <- round(dist.m, 0)
    
    # assemble into data frame
    aberrant <- my.taxon.flat 
    
    # remove unnecessary columns
    aberrant <- aberrant[,1:16]
    
    # return crs to longlate
    aberrant <- aberrant %>% st_transform(crs = 4326)
    
    # distance: change to km
    aberrant$dist.km <- as.numeric(dist.m)/1000
    
    # long lat
    longlat <- st_coordinates(aberrant) %>% as.data.frame()
    longlat <- longlat %>% rename(lat = Y, long = X)
    
    # remove coordinates
    st_geometry(aberrant) <- NULL
    
    # join
    aberrant <- cbind(aberrant, longlat)
    
    # add notes
    aberrant$notes  <- ifelse(aberrant$dist.km >= input$aberrant, input$notes, NA)
    
    # filter by distance
    aberrant <- aberrant %>% filter(dist.km >= input$aberrant)
    
    # remove unwanted columns 
    aberrant <- aberrant[, -c(1:4)]
    
    # return
    aberrant 
    
 } else {
   
   aberrant <- data.frame(Type = "Catchment", Notes = "Not appliable for catchments")
   aberrant
   
 }

  
})


renderDataTable({
  
  if (nrow(aberrant()) > 0){
   

    datatable(aberrant(), 
                  options = list(filter = "none",
                  scroll = TRUE, "pageLength" = 8))
    
  } else {
    
    data.frame(Notes = paste0("No aberrant records at a threshold of ", input$aberrant, "m"))
    
  }
})
    


```


### File check

Files present:

```{r}


renderPrint({
  A <- list.files(paste0(getwd(), "/Your Species Polylines"))
  
  if (identical(A, character(0)) == TRUE) {
    your_polylines = "No files are present. If using this option please copy file(s) into: 'Your Species Polylines'"
    
  } else {
    your_polylines = A
  }
  
  
  B <-
    list.files(paste0(getwd(), "/Your Catchment Polygons"))
  
  if (identical(B, character(0)) == TRUE) {
    your_catchment = "No files are present. If using this option please copy file(s) into: 'Your Catchement Polygons'"
    
  } else {
    your_catchment = B
  }
  
  
  C <-
    list.files(paste0(getwd(), "/Your Non-Migratory Freshwater Fish Distribution"))
  
  if (identical(C, character(0)) == TRUE) {
    your_fish = "No files are present. If using this option please copy file(s) into: 'Your Non-Migratory Freshwater Fish Distribution"
    
  } else {
    your_fish = C
  }
  
  D <- list.files(paste0(getwd(), "/Your Species Polygons"))
  
  if (identical(C, character(0)) == TRUE) {
    your_fish = "No files are present. If using this option please copy file(s) into: 'Your Species Polygons"
    
  } else {
    your_polygons = D
  }
  
  list(
    "Catchment check" = your_catchment,
    "Non-migratory fish check" = your_fish,
    "Polygon check" = your_polygons,
    "Polyline check" = your_polylines
  )
  
})  
  
```