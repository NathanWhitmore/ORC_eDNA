---
title: "ORC eDNA dashboard"
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "reproducible.co.nz", href: "https://reproducible.co.nz", align: right }
    orientation: rows
    vertical_layout: fill
    theme: spacelab
    source_code: embed 
---
<style>

body {
  padding-top: 70px;
}


.navbar-brand {
font-family: "Candara";
  font-weight: bold;
  font-size: 24px;
}


</style>


Sample locations
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**In this dashboard are 4 pages:**

1. **Sample locations**  - which shows all sampling locations
1. **By taxon** - which allows disaggregation by species/subspecies
1. **By spatial** - which allows disaggregation by species/subspecies or a specific taxon
1. **By cluster** - which allows investigation of species/subspecies clusters


**Your NZTCS data was last modified on: **


```{r}
library(wilderlab)
library(insect)
library(sf)
library(tidyverse)
library(lubridate)
library(leaflet)
library(shiny)
library(shinyWidgets)
library(flexdashboard)
library(plotly)
library(viridis)
library(DT)
library(readxl)
library(factoextra)
library(leaflet.extras)
library(geojsonsf)
library(jsonify)
library(stringr)


# read NZTCS data
nztcs <- read_excel("Data/NZTCS.xlsx")

renderUI({
  
  modification.time <- file.info("NZTCS.xlsx")$mtime
  print(modification.time)
  
  
})

  
 
```

**Please check that is the appropriate version for your analysis**


```{r}
radioButtons(
  "province",
  label = "Clip data by province?",
  choices = list(
    "No" = "No",
    "Yes" = "Yes"
  ),
  selected = "Yes"
  
)
```



```{r}
# maximum 50 MB
options(shiny.maxRequestSize=50*1024^2) 

# select provincial boundaries
boundaries <- st_read("Regional boundaries\\regional-council-2022-generalised.shp", quiet = TRUE)

province.choice <- sort(unique(boundaries$REGC2022_1))

```


```{r}
# only reveal if "yes" selected

conditionalPanel(
  condition = "input.province == 'Yes'",
  
  selectInput(
    "my.province",
    label = "Clip by province:",
    choices = province.choice,
    selected = "Otago Region"
  )
  
)

# crop to catchment (actually crop) to create usable subset
my.clip.province <- reactive({
  if (input$province == "Yes") {
    boundaries %>% filter(boundaries$REGC2022_1 == input$my.province)
    
  } else {
    boundaries
  }
})

```


Row {.tabset .tabset-fade}
-------------------------------------
### Zoomable map

```{r}
# APIs
APIs <- read_excel("Data/API keys.xlsx")


# get job info

jobs <- get_wilderdata("jobs", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
samples <- get_wilderdata("samples", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
taxa <- get_wilderdata("taxa", key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)

# get full record
records <- vector(mode = "list", length = nrow(jobs))
for(i in seq_along(records)){
  records[[i]] <- get_wilderdata("records", JobID = jobs$JobID[i],
                                 key = APIs$key, secret = APIs$secret, xapikey = APIs$xapikey)
}
records <- do.call("rbind", records)


# add taxa info
tdb <- taxa[, 1:4]
colnames(tdb) <- c("taxID", "parent_taxID", "rank", "name")
lineages <- insect::get_lineage(records$TaxID, tdb)

# add classification
records$phylum <- sapply(lineages, "[", "phylum")
records$class <- sapply(lineages, "[", "class")
records$order <- sapply(lineages, "[", "order")
records$family <- sapply(lineages, "[", "family")
records$genus <- sapply(lineages, "[", "genus")
records$species <- sapply(lineages, "[", "species")
records$Latitude <- samples$Latitude[match(records$UID,samples$UID)]
records$Longitude <- samples$Longitude[match(records$UID,samples$UID)]
records$ClientSampleID <- samples$ClientSampleID[match(records$UID,samples$UID)]

# date join
date.id <- samples[, c("UID", "CollectionDate")]

# add dates to record
eDNA <- left_join(records, date.id, by = "UID")


```





```{r, message = FALSE}
# read in standardised fmu shapefile (created in eDNA base code)

# read in eDNA data (fast)
eDNA <- eDNA %>% # data provided by Wilderlab
  janitor::clean_names()


# this is because data does not match Otago region
# now 16 secs rather than 145 secs
eDNA_my_prov_sf <- reactive ({
  
  eDNA_my_prov_sf  <- eDNA %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  st_intersection(my.clip.province())
  
  # fix dates
  eDNA_my_prov_sf$collection_date <- ymd(eDNA_my_prov_sf $collection_date )
  
  # unique coord
  eDNA_coord <- st_coordinates(eDNA_my_prov_sf) %>% as.data.frame()
  eDNA_coord$xy <- paste(eDNA_coord$X, eDNA_coord$Y)
  eDNA_my_prov_sf <- cbind(eDNA_my_prov_sf, eDNA_coord$xy)
  eDNA_my_prov_sf
  
})


# sample locations (fast) by first date
site.locations <- reactive({
  
  eDNA_my_prov_sf() %>%  
    group_by(eDNA_coord.xy) %>%
    filter(collection_date == min(collection_date)) %>%
    slice(1) 
  
})


# make base map
basemap <- reactive({
  
  leaflet() %>%
  # add different provider tiles
  addProviderTiles(
    "OpenStreetMap",
    # give the layer a name
    group = "OpenStreetMap"
  ) %>%
  addProviderTiles(
    "Esri.WorldImagery",
    # give the layer a name
    group = "World"
  ) %>%
  addPolygons(data = my.clip.province(),
              weight = 1,
              fillOpacity = 0.05,
              color = "white")
  })


# visualise site locations
renderLeaflet({
  
  basemap() %>%
  addCircleMarkers(data = site.locations() ,
                   clusterOptions = markerClusterOptions(),
                   popup = ~client_sample_id) %>%
  addMiniMap()

})





```

### Meshed

```{r}



renderLeaflet ({
  
  # override any random origin of grid if it exists
  set.seed(500)
  
  catch.2193 <- my.clip.province() %>%
    st_transform(crs = 2193)
  
  
  grid <- st_make_grid(
    catch.2193,
    cellsize = c(10000, 10000),
    crs = 2193,
    square = TRUE
  ) %>%
    st_as_sf()
  
  inter <- st_intersection(catch.2193, grid) %>%
    st_transform(crs = 4236)
  
  leaflet() %>%
    # add different provider tiles
    addProviderTiles("Esri.WorldImagery",
                     # give the layer a name
                     group = "World") %>%
    addPolygons(
      data = inter,
      weight = 1,
      fillOpacity = 0.05,
      color = "white"
    ) %>%
    addMiniMap()
  
})
```




By classification
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Filter by taxonomy**



```{r}
selectInput(
  "Classification",
  label = "Taxonomic group",
  choices = list(
    "Phylum" = "phylum",
    "Class" = "class",
    "Order" = "order",
    "Family" = "family",
    "Genus" = "genus",
    "Species" = "species"
  ),
      selected = "species"
)


# reactive taxonomic choices

renderUI({
  
  my.selection <- eDNA_my_prov_sf() %>% select(input$Classification)
  st_geometry(my.selection) <- NULL
  
  choices <- sort(unique(my.selection[, 1]))
  
  selectInput("Taxon",
              label = str_to_title(input$Classification),
              choices = sort(unique(choices)),
              selected = "Galaxias gollumoides")
  
})


# reactive species/subspecies choices

my.spp <- reactive({
  x <- as.character(input$Classification)
  
  eDNA_my_prov_sf() %>% 
    filter(eval(str2expression(x)) == input$Taxon)
  
})


```




```{r}
my.taxon <- reactive({
  
  # start reactive
  
  x <- as.character(input$Classification)
  eDNA_my_prov_sf() %>% 
    filter(eval(str2expression(x)) == input$Taxon)
  
})

my.coord <- reactive ({
  
  my.coord <- st_coordinates(site.locations()) %>%
     as.data.frame()
  
  my.coord$xy <- paste(my.coord$X, my.coord$Y)
  my.coord
  
})




```




Row {data-height=75}
-------------------------------------

### Percentage of locations
```{r}

percentage_of_locations <- reactive({
   round(length(unique(my.sf.coord()$xy))/
    length(unique(my.coord()$xy)),4)  * 100
})


renderGauge({
  
gauge(percentage_of_locations(), min = 0, max = 100,  symbol = '%',
    gaugeSectors(colors = "#f93b25"))
})
```


### No. of unique sites
```{r}

no_of_actual_sites <- reactive({
  
  length(unique(my.sf.coord()$xy))
  
})

renderValueBox({

  valueBox(no_of_actual_sites(), color = " #7dcea0")
  
})
```



### No. of unique dates
```{r}

no_dates <- reactive({
  
  length(unique(my.taxon()$collection_date))
  
})

renderValueBox({
  
  valueBox(no_dates(),  color = "#7fb3d5")
  
})
```


Row {.tabset .tabset-fade}
-------------------------------------

### Presence / absence


```{r}


loc.map <- reactive({
  
  
  # visualise site locations
  
  basemap() %>%
    addCircleMarkers(
      data = my.taxon() ,
      color = "red",
      fillOpacity = 0.01,
      popup = paste(
        "Date:",
        my.taxon()$collection_date,
        "<br>",
        "Job id:",
        my.taxon()$job_id,
        "<br>",
        "Client:",
        my.taxon()$client_sample_id,
        "<br>",
        "Count:",
        my.taxon()$count,
        "<br>",
        "RID:",
        my.taxon()$rid,
        "<br>"
      )
    ) %>%
   addMiniMap()
  
})
  

```



```{r}
renderLeaflet({
  
  loc.map() %>%   
    addCircleMarkers(
      data = site.locations(),
      color = "white",
      fillOpacity = 0.01,
      radius = 10
    ) %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
  
})
```


### NZTCS data

```{r}

sp.info <- reactive({
  
  
  if(input$Classification != "species"){
    
    data.frame(Information = paste("Only available for species, not ", 
                                   input$Classification))
    
  } else {
  
  
  
  if (any(nztcs$`Current Species Name` == input$Taxon)){
  
  sp.info <- nztcs %>% filter(`Current Species Name` ==
                                input$Taxon)
  sp.info <- sp.info[, 1:41]
  sp.info <- t(sp.info) %>% as.data.frame()
  
  sp.info <- sp.info %>% rownames_to_column()
  colnames(sp.info) <- c("Attribute", "Status")
  
  sp.info} else {
    
    empty <- data.frame(Species = input$Taxon, Status = "Is either not present in the NZTCS or appears under a different name")
    empty
  }
    
  }
  
})



renderDataTable({
  
  
  datatable(
    sp.info(),
    rownames = FALSE,
    options = list(
      filter = "none",
      scrollY = "500px",
      "pageLength" = 42,
      searching = FALSE,
      dom = "t",
      info = FALSE
    )
  )
  
  
}, fillContainer = TRUE) 
  



```

### Sample data


```{r}

renderDataTable({
  
    temp <- my.taxon()
    my.coord <- st_coordinates(temp)
    st_geometry(temp) <- NULL
    my.species.coord <- cbind(temp, my.coord) %>% 
      rename(lat = Y, long = X)

  
    datatable(my.species.coord, 
                  options = list(filter = "none",
                  scroll = TRUE, "pageLength" = 8))

  
    
})

```

### Meta data


```{r}



# reactive elements
my.sf.coord <- reactive({
  
  my.sf.coord <- st_coordinates(my.taxon()) %>%
     as.data.frame()
  my.sf.coord$xy <- paste(my.sf.coord$X, my.sf.coord$Y)
  my.sf.coord
  
})
   
   

renderPrint({
  

  
list(
    species = input$Taxon,
    `no of dates` = no_dates(),
    dates = unique(my.taxon()$collection_date),
    `no. of site sample names (note: not standardised, synonyms possible)`= length(unique(my.taxon()$client_sample_id)),
    `site / client id names` = unique(my.taxon()$client_sample_id),
    `no. of actual sites with species detected` = no_of_actual_sites(),
    `total sampling locations` = length(unique(my.coord$xy)),
    `percentage of sampling locations` = percentage_of_locations() 
    
  )
  
})

    



```


By spatial
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Options**

You can either:

1. Upload a predefined shapefile or kml file
2. Select an area either square, circular, or a polygon on the fly

The eDNA data will extracted for your selected area.

**Please select**

```{r}
radioButtons(
  "choice",
  label = "One of:",
  choices = list("upload spatial file" = "upload", "draw now" = "draw"),
  selected = "draw"
)


conditionalPanel(
  condition = "input.choice == 'upload'",
  
  fileInput("file1", "Choose Shape File",
                    multiple = FALSE),
  
  )



```

```{r}
# reactive data from maps

dataset <- eventReactive(input$file1,{
  
  dataset <- st_read(input$file1$datapath, quiet = TRUE)

})


# selction from drawing
sp.file <- eventReactive(input$mymap_draw_new_feature,{
  
    feature <- input$mymap_draw_new_feature
    
    sp.file <-  geojson_sf(to_json(feature, unbox = TRUE)) %>%
      st_as_sf()
    
    sp.file
     
  })

```


```{r}

renderUI({
  
  # round to nearest 10
  nearest <- 10
  my.max <- ceiling(nrow(all.selection())/nearest)*nearest
  
  sliderInput("entries", "Number of entries to graph:",
            min = 10, max = my.max, value = 50, step = 10, ticks = FALSE)
  
})

renderUI({
  
  spp <- nrow(all.selection())
  paste("Total taxa present: ", spp)


})

```

*Note: When drawing a new polygon please allow a short period of time for the plot to render using the new data.*

**Download filtered data**

```{r}
# Create placeholder for the download button
uiOutput("downloadUI")
```

```{r, echo = FALSE}
output$downloadUI <- renderUI( {
  downloadButton("downBtn", "Download csv data", style = "width:100%;")
})

output$downBtn <- downloadHandler(
  filename = function() {'Name your file.csv'},
  content = function(file) {
    write.csv(final(), file, row.names = FALSE)
  }
)
```

**Download shapefile**

```{r}
# Create placeholder for the download button
uiOutput("downloadUIsp")
```

```{r, echo = FALSE}
output$downloadUIsp <- renderUI( {
  downloadButton("downBtnsp", "Download shapefile", style = "width:100%;")
})

output$downBtnsp <- downloadHandler(
  filename = function() {'Name your file.csv'},
  content = function(file) {
    write.csv(final(), file, row.names = FALSE)
  }
)
```


Row {.tabset .tabset-fade}
-------------------------------------

### Zoomable map


```{r}
my.selection <- reactive({
  
  if (input$choice == "upload") {
    
    eDNA_my_prov_sf() %>%
      st_as_sf(coords = c("longitude", "latitude"),
               crs = 4326) %>%
      st_intersection(dataset())
    
  } else {
    
    if (sp.file()$feature_type == "circle") {
      
      my.circle <- st_buffer(sp.file(), sp.file()$radius) 
      
      eDNA_my_prov_sf() %>%
        st_as_sf(coords = c("longitude", "latitude"),
                 crs = 4326) %>%
        st_intersection(my.circle)
      
    } else {
      
      eDNA_my_prov_sf() %>%
        st_as_sf(coords = c("longitude", "latitude"),
                 crs = 4326) %>%
        st_intersection(sp.file())
      
    }
  }

})

```

```{r}


leafletOutput("mymap", height = 800)

output$mymap <- renderLeaflet({
  
  if (input$choice == "upload") {
    
    site.polygon <- dataset() %>% st_zm()
    
    new.map <- basemap() %>%
      addCircleMarkers(
        data = my.selection() ,
        clusterOptions = markerClusterOptions(),
        popup = ~ client_sample_id
      ) %>%
      addPolygons(data = site.polygon, color = "white") %>%
      addMiniMap()
    

    
  } else {
    
    leaflet() %>%
      
      # add base maps
      addProviderTiles("OpenStreetMap",
                       # give the layer a name
                       group = "Open Street Map") %>%
      addProviderTiles("Esri.WorldImagery",
                       # give the layer a name
                       group = "World") %>%
      addProviderTiles("Stamen.Terrain",
                       # give the layer a name
                       group = "Terrain") %>%
      
      # set zoom and position
      setView(lng = 169,
              lat = -45.9,
              zoom = 8) %>%
      
      # add drawing tools
      addDrawToolbar(
        polylineOptions = FALSE,
        markerOptions = FALSE,
        circleMarkerOptions = FALSE,
        singleFeature = TRUE,
        
        
        targetGroup = 'draw',
        editOptions = editToolbarOptions(edit = FALSE, remove = TRUE)
      )  %>%
      
      # add layers
      addLayersControl(overlayGroups = c('draw'),
                       options =
                         layersControlOptions(collapsed = FALSE)) %>%
      
      addLayersControl(
        baseGroups = c("World", "Terrain", "Open Street Map"),
        # position it on the topleft
        position = "topleft"
      ) %>%
      
      addMarkers(data = site.locations())%>%
      addMiniMap()
    
  }
  
})


```

### Taxa present
```{r}
all.selection <- reactive({
  
  my.table <- my.selection() %>% 
    filter(rank == "species" |rank == "subspecies") %>% 
    group_by(name)  %>%
    summarise(instances = n(),
              `average count` = round(mean(count),1),
              `range` = paste(min(count),"â€“", max(count) )
              ) 
  
  st_geometry(my.table) <- NULL
  my.table
  
})
```


```{r}
selection <- reactive({
  
    selection <- all.selection() %>% 
      slice_max(instances, n = input$entries) 
  
    selection$name <- as.factor(selection$name)
    selection <- selection %>% mutate(name, name = fct_reorder(name, -instances))
    selection
  
})



renderPlotly({

  

  ggplot(selection(), aes(x = name ,
      y = instances,
      fill = `average count`,
      text = paste("range:", range))) +
    theme_minimal() +
    geom_col() +
    scale_fill_viridis(option = "plasma") +
    xlab("") +
    ylab("Instances\n") +
    ggtitle("Taxon present in spatial selection") +
    theme(axis.title = element_text(size = 16, colour = "grey20")) +
    theme(axis.text.x = element_text(
      size = 12,
      colour = "grey20",
      angle = 90,
      hjust = 1,
      vjust = 0.5
    ))
  
})
```

### Data

```{r}
renderDataTable({
  
    datatable(all.selection(), 
                  options = list(filter = "none",
                  scrollX = TRUE, "pageLength" = 15))
    
})

```


### Area

```{r}
renderUI({
  
  if(sp.file()$feature_type == "circle"){
    
   area <- st_buffer(sp.file(), sp.file()$radius) %>% st_area()
    
  } else {
    
   area <- sp.file() %>% st_area()
     
  }
  
  
  line1 <- paste("area (sq m) =",  round(area,2))
  line2 <-paste("area (ha) =",  round(area/10000,2))
  line3 <-paste("area (km) =",  round(area/1000000,2))
  
  HTML(paste(line1, line2, line3, sep = '<br/>'))

  
})
    
```

### Testing

```{r}
renderPrint({
  
  all.selection()
  
})
```


By cluster
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Number of clusters**


```{r}
sliderInput("cluster", label = "No. of clusters", min = 2, 
        max = 10, value = 2, step = 1)
```

Row {.tabset .tabset-fade}
-------------------------------------
### Dendrogram

```{r}
my.clust <- reactive ({
  # simplifed data
  my.dna <- eDNA %>% filter(rank == "species" |
                                rank == "subspecies" )
  
  my.dna <- my.dna[, c("name", "latitude", "longitude", "uid")]
  
  # make future rowname
  my.dna$longlat <- paste(my.dna$longitude, my.dna$latitude)
  
  # add count
  my.dna$count <- 1
  
  # group and summarise
  my.dnax <- my.dna  %>% group_by(longlat,  name) %>%
    summarise(presence = sum(count))
  
  # reduce so row number is correct
  my.dnax$presence <- ifelse(my.dnax$presence > 1, 1, 1)
  
  # pivot wider
  my.dnax <- my.dnax %>% pivot_wider(names_from = name,
                                     values_from = presence) %>% as.data.frame()
  
  # make row names
  rownames(my.dnax) <- paste0(my.dnax$longlat)
  
  # remove unnecessary columns
  my.dnax$longlat <- NULL
  my.dnax$uid <- NULL
  
  # change NAs to 0
  my.dnax[is.na(my.dnax)] <- 0
  

  # hierarchical clustering
  my.clust <-  my.dnax %>%
    dist(method = "euclidean") %>%
    hclust(method = "ward.D")
  
  my.clust
  
})
  
  
# graph

renderPlot({
  
  fviz_dend(my.clust(), k=input$cluster)
  
})


```

### Map

```{r}

renderLeaflet({
  
  my.dna <- eDNA[, c("name", "latitude", "longitude", "uid")]
  
  # make future rowname
  my.dna$longlat <- paste(my.dna$longitude, my.dna$latitude)
  
  # add count
  my.dna$count <- 1
  
  # group and summarise
  my.dnax <- my.dna  %>% group_by(longlat,  name) %>%
    summarise(presence = sum(count))
  
  # reduce so row number is correct
  my.dnax$presence <- ifelse(my.dnax$presence > 1, 1, 1)
  
  # pivot wider
  my.dnax <- my.dnax %>% pivot_wider(names_from = name,
                                     values_from = presence) %>% as.data.frame()
  
  # make row names
  rownames(my.dnax) <- paste0(my.dnax$longlat)
  
  # remove unnecessary columns
  my.dnax$longlat <- NULL
  my.dnax$uid <- NULL
  
  # change NAs to 0
  my.dnax[is.na(my.dnax)] <- 0
  
  
  clust.map <- my.dnax
  
  # assign cluster
  my.clust <-  my.dnax %>%
    dist(method = "euclidean") %>%
    hclust(method = "ward.D")
  
  clust.map$groups <- as.factor(cutree(my.clust, k = input$cluster))
  
  # simplify and back calculate row names
  clust.map$longlat <- rownames(clust.map)
  clust.map <- clust.map[, c("groups", "longlat")]
  
  clust.map <-
    clust.map %>% separate(longlat, c("longitude", "latitude"),  sep = " ")
  
  clust.map <- st_as_sf(clust.map,
               coords = c("longitude", "latitude"),
               crs = 4326)

  clust.map <- as_Spatial(clust.map)
  
  # make base map
  map.clust <- leaflet() %>%
    addProviderTiles("Esri.WorldImagery",
                     group = "World")
  
  beatCol <- colorFactor(palette = 'RdYlGn', clust.map$groups)
  
  
  # visualise site locations
  site.map <- map.clust %>%
    addCircleMarkers(data = clust.map, color = ~ beatCol(groups)) %>%
   addMiniMap()
  
  site.map
  
  
  
  
})
```


Test existing knowledge
=====================================

Column {.sidebar}
-----------------------------------------------------------------------

**Provide files**

Please ensure a *maximum* of 1 spatial file / spatial file set is placed into the correct folder. Use the **File check** tab to check.

If you alter the inputs you will need to push "activate" to update the results.



```{r}

# spatial radio button

radioButtons(
  "spatialfile",
  label = "Type",
  choices = list(
    "Single species polyline" = "polyline",
    "Single species polygon" = "polygon",
    "Catchment polygon" = "catchment",
    "Non migratory freshwater fish distribution" = "nmfish"
  ),
  selected = "nmfish"
  
)
```


**Your current eDNA record is of:**

```{r}
# base species is reactive to ensure it corresponds with data
base_species <- eventReactive(input$submit,
                              {
                                input$Taxon
                              })


renderUI({
  
  base_species()
  
})
```




```{r}
# my.shape determined by user selection

my.shape <- reactive({
  
  if (input$spatialfile == "nmfish") {
    my.shape <-
      st_read(
        "Your Non-Migratory Freshwater Fish Distribution/Non_migratory_Freshwater_Fish_Distribution.shp",
        quiet = TRUE
      ) %>%
      st_transform(crs = 4326)
    my.shape
    
    
  } else if (input$spatialfile == "catchment") {
    filenames <- list.files(paste0(getwd(), "/Your Catchment Polygons"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape2  <-
      st_read(paste0("Your Catchment Polygons/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape2
    
  } else if (input$spatialfile == "polyline") {
    
    filenames <- list.files(paste0(getwd(), "/Your Species Polylines"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape3  <-
      st_read(paste0("Your Species Polylines/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape3
    
  } else {
  
  filenames <- list.files(paste0(getwd(), "/Your Species Polygons"))
    
    # get shapefile
    my.file <- filenames[grep("shp$", filenames)]
    
    my.shape4  <-
      st_read(paste0("Your Species Polygons/", my.file), quiet = TRUE) %>%
      st_make_valid() %>%
      st_transform(crs = 4326)
    
    my.shape4
  }
    

  
})
```


```{r}
# my.catchment conditional selections
# conditional on submit

catchment.choices <- reactive({
                         
  if (input$spatialfile == "catchment") {
    poly.catchment <- my.shape()
    st_geometry(poly.catchment) <- NULL
    catchment.names <- select_if(poly.catchment, is.character) %>% names()
    catchment.choices <- sort(catchment.names)
    catchment.choices
    
  } else {
    catchment.choices <- NULL
    catchment.choices
  }
})

# species choices for catchment
renderUI({
  conditionalPanel(condition = "input.spatialfile == 'catchment'",
                   
                   selectInput("catchment.var",
                               label = "Pop up information from:",
                               choices = catchment.choices()))
  
})

```


```{r}


# nmfish conditional selections
non.mig.choices <- reactive({
                         
  if (input$spatialfile == "nmfish") {
    nmfish <- my.shape()
    st_geometry(nmfish) <- NULL
    non.mig.choices <- sort(unique(nmfish[, 3]))
    non.mig.choices
  }
})

# species choices from nmfish
renderUI({
  conditionalPanel(condition = "input.spatialfile == 'nmfish'",
                   
                   selectInput("non.mig.sp",
                               label = "Species for comparison:",
                               choices = non.mig.choices()))
  
})


# distance threshold for nmfish
renderUI({
  conditionalPanel(
    condition = "input.spatialfile == 'nmfish' |
    input.spatialfile == 'polyline'"  ,
    
    numericInput("aberrant", label = "Distance threshold for aberrant result (nearest m)", value = 1000)
  )
  
})
```
  

**Write note for csv file**
```{r}
textInput("notes", label = "", value = "Enter text...")
```

<br/>

```{r}
# add submit button
actionButton("submit", label = "Activate")
```

<br/>

**Download csv of aberrant entries**

```{r}
# Create placeholder for the download button
uiOutput("downloadfish")
```

```{r, echo = FALSE}
output$downloadfish <- renderUI( {
  downloadButton("downBtnfish", "Download csv", style = "width:100%;")
})

output$downBtnfish <- downloadHandler(
  filename = function() { paste0("edna-", input$Taxon, " vs ", 
                                 "target-", input$non.mig.sp, " ",
                                 "threshold-", input$aberrant,"m",".csv")},
  content = function(file) {
    write.csv(aberrant(), file, row.names = FALSE)
  }
)
```




Row {.tabset .tabset-fade}
-------------------------------------



### Zoomable map

```{r}
my.map <- eventReactive(input$submit,
                        {
                           nearest <- NULL
                          
                          
                          if (input$spatialfile == "nmfish") {
                            non.mig.sp <-
                              my.shape() %>%
                              filter(Species == input$non.mig.sp) %>%
                              st_make_valid()
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), non.mig.sp)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), non.mig.sp[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and nearest known 
                            # location via loop
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  non.mig.sp[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            
                            loc.map() %>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) %>%
                              addPolylines(data = non.mig.sp ,
                                           color = "yellow",
                                           weight = 3)
                            
                            
                          } else if (input$spatialfile == "polyline") {
                            my.species <-
                              my.shape() %>%
                              st_make_valid()
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), my.species)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), my.species[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and 
                            # nearest known location via loop
                            
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  my.species[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            
                            loc.map() %>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) %>%
                              addPolylines(data = my.species ,
                                           color = "yellow",
                                           weight = 3)
                            
                            
                          } else if (input$spatialfile == "catchment") {
                            # work out if in or out
                            my.catchment <- my.shape()
                            my.catchment$present <-
                              lengths(st_intersects(my.catchment, my.taxon())) > 0
                            my.catchment$present <-
                              ifelse(my.catchment$present == TRUE, "red", "black")
                            
                            loc.map() %>%
                              addPolygons(
                                data = my.catchment,
                                fillColor = ~ present,
                                color = "white",
                                weight = 1,
                                fillOpacity = 0.3,
                                highlightOptions = highlightOptions(
                                  color = 'white',
                                  weight = 1,
                                  bringToFront = TRUE
                                ),
                                popup = my.catchment[[input$catchment.var]]
                              )
                            
                            
                          } else {
                            # work out if in or out
                            my.polygon <- my.shape()
                            my.polygon$present <-
                              lengths(st_intersects(my.polygon, my.taxon())) > 0
                            my.polygon$present <-
                              ifelse(my.polygon$present == TRUE, "red", "black")
                            
                            # get nearest
                            nearest <- st_nearest_feature(my.taxon(), my.polygon)
                            
                            # get distance
                            dist <-
                              st_distance(my.taxon(), my.polygon[nearest,], 
                                          by_element = TRUE)
                            
                            # make line between points and 
                            # nearest known location via loop
                            
                            my.feature <- list()
                            
                            for (i in 1:nrow(my.taxon())) {
                              my.feature[[i]] <-
                                st_nearest_points(my.taxon()[i, ],
                                                  my.polygon[nearest[i], ]) %>%
                                st_sf()
                            }
                            
                            # nearest jump
                            nearest_jump <- bind_rows(my.feature)
                            
                            loc.map() %>%
                              addPolygons(
                                data = my.polygon,
                                fillColor = ~ present,
                                color = "white",
                                weight = 1,
                                fillOpacity = 0.3,
                                highlightOptions = highlightOptions(
                                  color = 'white',
                                  weight = 1,
                                  bringToFront = TRUE
                                )
                              )%>%
                              addPolylines(data = nearest_jump,
                                           color = "white",
                                           weight = 2) 
                            
                          }
                          
                        })


renderLeaflet ({
  
  my.map() %>%
    addScaleBar(position = "topright",
              options = scaleBarOptions(imperial = FALSE)) 
  
  
})
```




### Sample data

```{r}

aberrant <- eventReactive(input$submit,
                       {
  
 if (input$spatialfile == "nmfish" |
     input$spatialfile == "polyline"|
     input$spatialfile == "polygon" ){
   
   if (input$spatialfile == "nmfish") {
     
   my.selected.species <- my.shape() %>% 
     filter(Species == input$non.mig.sp) %>% 
     st_make_valid()
   
   } else {
     
    my.selected.species <- my.shape() %>% 
     st_make_valid()
     
   }
  
    # get nearest
    nearest <- st_nearest_feature(my.taxon(), my.selected.species)
    
    # flatten (change crs to NZTM for distance calculation)
    my.taxon.flat <- my.taxon() %>% st_transform(crs = 2193)
    my.selected.species.flat <- my.selected.species  %>% 
      st_transform(crs = 2193)
    
    # get distance
    dist.m <-
      st_distance(my.taxon.flat , my.selected.species.flat[nearest,], 
                  by_element = TRUE)
    dist.m <- round(dist.m, 0)
    
    # assemble into data frame
    aberrant <- my.taxon.flat 
    
    # remove unnecessary columns
    aberrant <- aberrant[,1:16]
    
    # return crs to longlate
    aberrant <- aberrant %>% st_transform(crs = 4326)
    
    # distance
    aberrant$dist.m <- as.numeric(dist.m)
    
    # long lat
    longlat <- st_coordinates(aberrant) %>% as.data.frame()
    longlat <- longlat %>% rename(lat = Y, long = X)
    
    # remove coordinates
    st_geometry(aberrant) <- NULL
    
    # join
    aberrant <- cbind(aberrant, longlat)
    
    # add notes
    aberrant$notes  <- ifelse(aberrant$dist.m >= input$aberrant, input$notes, NA)
    
    # filter by distance
    aberrant <- aberrant %>% filter(dist.m >= input$aberrant)
    
    # remove unwanted columns 
    aberrant <- aberrant[, -c(1:4)]
    
    # return
    aberrant 
    
 } else {
   
   aberrant <- data.frame(Type = "Catchment", Notes = "Not appliable for catchments")
   aberrant
   
 }

  
})


renderDataTable({
  
  if (nrow(aberrant()) > 0){
   

    datatable(aberrant(), 
                  options = list(filter = "none",
                  scroll = TRUE, "pageLength" = 8))
    
  } else {
    
    data.frame(Notes = paste0("No aberrant records at a threshold of ", input$aberrant, "m"))
    
  }
})
    


```


### File check

Files present:

```{r}


renderPrint({
  A <- list.files(paste0(getwd(), "/Your Species Polylines"))
  
  if (identical(A, character(0)) == TRUE) {
    your_polylines = "No files are present. If using this option please copy file(s) into: 'Your Species Polylines'"
    
  } else {
    your_polylines = A
  }
  
  
  B <-
    list.files(paste0(getwd(), "/Your Catchment Polygons"))
  
  if (identical(B, character(0)) == TRUE) {
    your_catchment = "No files are present. If using this option please copy file(s) into: 'Your Catchement Polygons'"
    
  } else {
    your_catchment = B
  }
  
  
  C <-
    list.files(paste0(getwd(), "/Your Non-Migratory Freshwater Fish Distribution"))
  
  if (identical(C, character(0)) == TRUE) {
    your_fish = "No files are present. If using this option please copy file(s) into: 'Your Non-Migratory Freshwater Fish Distribution"
    
  } else {
    your_fish = C
  }
  
  D <- list.files(paste0(getwd(), "/Your Species Polygons"))
  
  if (identical(C, character(0)) == TRUE) {
    your_fish = "No files are present. If using this option please copy file(s) into: 'Your Species Polygons"
    
  } else {
    your_polygons = D
  }
  
  list(
    "Catchment check" = your_catchment,
    "Non-migratory fish check" = your_fish,
    "Polygon check" = your_polygons,
    "Polyline check" = your_polylines
  )
  
  
})  
  

```